/*
 * Copyright (c) 2010 Stan Coleby (scoleby@intelisum.com)
 * Copyright (c) 2020 PTC Inc.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

//! @file E57Simple.cpp

// for M_PI. This needs to be first, otherwise we might already include math header
// without M_PI and we would get nothing because of the header guards.
#define _USE_MATH_DEFINES
#include <cmath>

#include "E57Simple.h"
#include "E57SimpleImpl.h"

using namespace e57;
using namespace std;

// to avoid exposing M_PI constructor is here
SphericalBounds::SphericalBounds()
{
 rangeMinimum = 0.;
 rangeMaximum = E57_DOUBLE_MAX;
 azimuthStart = -M_PI;
 azimuthEnd = M_PI;
 elevationMinimum = -M_PI/2.;
 elevationMaximum = M_PI/2.;
}

////////////////////////////////////////////////////////////////////
//
//	e57::Reader
//
			Reader :: Reader(const ustring & filePath)
: impl_(new ReaderImpl(filePath))
{
}

bool		Reader :: IsOpen() const
{
	return impl_->IsOpen();
};

bool		Reader :: Close() const
{
	return impl_->Close();
};

bool		Reader :: GetE57Root(
	E57Root & fileHeader) const
{
	return impl_->GetE57Root(fileHeader);
};

int64_t		Reader :: GetImage2DCount() const
{
	return impl_->GetImage2DCount();
};

bool		Reader :: ReadImage2D( 
	int64_t			imageIndex,
	Image2D &	image2DHeader) const
{
	return impl_->ReadImage2D(imageIndex,image2DHeader);
};

bool		Reader :: GetImage2DSizes(
	int64_t					imageIndex,		// This in the index into the image2D vector
	e57::Image2DProjection &imageProjection,// identifies the projection desired.
	e57::Image2DType &		imageType,		// identifies the image format desired.
	int64_t &				imageWidth,		// The image width (in pixels).
	int64_t &				imageHeight,	// The image height (in pixels).
	int64_t &				imageSize,		// This is the total number of bytes for the image blob.
	e57::Image2DType &		imageMaskType,	// This is E57_PNG_IMAGE_MASK if "imageMask" is defined in the projection
	e57::Image2DType &		imageVisualType	// This is image type of the VisualReferenceRepresentation if given.
	) const
{
	return impl_->GetImage2DSizes(imageIndex, imageProjection, imageType,
		imageWidth, imageHeight, imageSize, imageMaskType, imageVisualType);
};

int64_t		Reader :: ReadImage2DData(
	int64_t					imageIndex,		// picture block index
	e57::Image2DProjection	imageProjection,// identifies the projection desired.
	e57::Image2DType		imageType,		// identifies the image format desired.
	void *					pBuffer,	// pointer the buffer
	int64_t					start,		// position in the block to start reading
	int64_t					count		// size of desired chuck or buffer size
	) const
{
	return impl_->ReadImage2DData(imageIndex, imageProjection, imageType, pBuffer, start, count);
};

int64_t		Reader :: GetData3DCount() const
{
	return impl_->GetData3DCount();
};

// This function returns the ram ImageFile Node which is need to add enhancements
ImageFile		Reader :: GetRawIMF()
{
	return impl_->GetRawIMF();
}
// This function returns the file raw E57Root Structure Node
StructureNode	Reader :: GetRawE57Root()
{
	return impl_->GetRawE57Root();
};	// /return Returns the E57Root StructureNode

// This function returns the raw Data3D Vector Node
VectorNode		Reader :: GetRawData3D()
{
	return impl_->GetRawData3D();
};// /return Returns the raw Data3D VectorNode

// This function returns the raw Images2D Vector Node
VectorNode		Reader :: GetRawImages2D()
{
	return impl_->GetRawImages2D();
};	// /return Returns the raw Image2D VectorNode

bool		Reader :: ReadData3D( 
	int64_t		dataIndex,	// This in the index into the images3D vector
	Data3D &	data3DHeader // pointer to the Data3D structure to receive the image information
	) const	// /return Returns true if sucessful
{
	return impl_->ReadData3D(dataIndex, data3DHeader);
}

bool		Reader :: GetData3DSizes(
	int64_t		dataIndex,	// This in the index into the images3D vector
	int64_t &	rowMax,		// This is the maximum row size
	int64_t &	columnMax,	// This is the maximum column size
	int64_t &	pointsSize,	// This is the total number of point records
	int64_t &	groupsSize,	// This is the total number of group reocrds
	int64_t &	countSize,	//!< This is the maximum point count per group
	bool &		bColumnIndex	//!< This indicates that the idElementName is "columnIndex"
	) const
{
	return impl_->GetData3DSizes( dataIndex, rowMax, columnMax, pointsSize,
		groupsSize, countSize, bColumnIndex);
}

bool		Reader :: ReadData3DGroupsData(
	int64_t		dataIndex,			// data block index given by the NewData3D
	int64_t		groupCount,			// size of each of the buffers given
	int64_t*	idElementValue,		// index for this group
	int64_t*	startPointIndex,	// Starting index in to the "points" data vector for the groups
	int64_t*	pointCount			// size of the groups given
	) const							// \return Return true if sucessful, false otherwise
{
	return impl_->ReadData3DGroupsData(dataIndex, groupCount, idElementValue, startPointIndex, pointCount);
}

CompressedVectorReader	Reader :: SetUpData3DPointsData(
	int64_t		dataIndex,			// data block index given by the NewData3D
	size_t		pointCount,			// size of each element buffer.
	const Data3DPointsData& buffers //!< pointers to user-provided buffers
	) const
{
	return impl_->SetUpData3DPointsData( dataIndex, pointCount, buffers);
}

////////////////////////////////////////////////////////////////////
//
//	e57::Writer
//
			Writer :: Writer(
	const ustring & filePath,		// file path string
	const ustring & coordinateMetaData	// Information describing the Coordinate Reference System to be used for the file
): impl_(new WriterImpl(filePath, coordinateMetaData))
{
}

bool		Writer :: IsOpen() const
{
	return impl_->IsOpen();
};

bool		Writer :: Close() const
{
	return impl_->Close();
};

// This function returns the ram ImageFile Node which is need to add enhancements
ImageFile		Writer :: GetRawIMF()
{
	return impl_->GetRawIMF();
}

// This function returns the file raw E57Root Structure Node
StructureNode	Writer :: GetRawE57Root()
{
	return impl_->GetRawE57Root();
};	// /return Returns the E57Root StructureNode

// This function returns the raw Data3D Vector Node
VectorNode		Writer :: GetRawData3D()
{
	return impl_->GetRawData3D();
};// /return Returns the raw Data3D VectorNode

// This function returns the raw Images2D Vector Node
VectorNode		Writer :: GetRawImages2D()
{
	return impl_->GetRawImages2D();
};	// /return Returns the raw Image2D VectorNode

int64_t		Writer :: NewImage2D(
	Image2D &	image2DHeader	// pointer to the Image2D structure to receive the picture information
	) const						// /return Returns the image2D index
{
	return impl_->NewImage2D( image2DHeader);
};


int64_t		Writer :: WriteImage2DData(
	int64_t					imageIndex,		// picture block index given by the NewImage2D
	e57::Image2DType		imageType,		// identifies the image format desired.
	e57::Image2DProjection	imageProjection,// identifies the projection desired.
	void *					pBuffer,		// pointer the buffer
	int64_t					start,			// position in the block to start writing
	int64_t					count			// size of desired chuck or buffer size
	) const									// /return Returns the number of bytes written
{
	return impl_->WriteImage2DData( imageIndex, imageType, imageProjection, pBuffer, start, count);
};

int64_t		Writer :: NewData3D(
	Data3D &	data3DHeader,	// pointer to the Data3D structure to receive the image information
	bool		(*pointExtension)(ImageFile	imf, StructureNode proto)	//!< function pointer to add point data extension
	) const							// /return Returns the index of the new scan's data3D block.
{
	return impl_->NewData3D( data3DHeader, pointExtension);
};

// This function writes out blocks of point data
CompressedVectorWriter	Writer :: SetUpData3DPointsData(
	int64_t		dataIndex,			// data block index given by the NewData3D
	size_t		pointCount,			// size of each of the buffers given
	const Data3DPointsData& buffers //!< pointers to user-provided buffers
	) const
{
		return impl_->SetUpData3DPointsData( dataIndex, pointCount, buffers);
}

bool		Writer :: WriteData3DGroupsData(
	int64_t		dataIndex,			// data block index given by the NewData3D
	int64_t		groupCount,			//!< size of each of the buffers given
	int64_t*	idElementValue,		// index for this group
	int64_t*	startPointIndex,	// Starting index in to the "points" data vector for the groups
	int64_t*	pointCount			// size of the groups given
	) const								// \return Return true if sucessful, false otherwise
{
	return impl_->WriteData3DGroupsData(
		dataIndex, groupCount, idElementValue, startPointIndex, pointCount);
}

